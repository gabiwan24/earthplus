<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Organischer Halbmond - Animated</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            /* Hintergrund: Ein tiefer blauer Verlauf ("Blaufläche") statt flachem Schwarz */
            background: radial-gradient(circle at center, #001e45 0%, #000510 100%);
            color: #ccfbf1; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none; /* Keine Textauswahl */
            -webkit-user-select: none;
        }

        canvas {
            /* Canvas ist transparent, damit der Body-Gradient durchscheint */
            background-color: transparent; 
            touch-action: none; 
        }

        .controls-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 5, 16, 0.85);
            backdrop-filter: blur(12px);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #083344;
            width: 320px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
            z-index: 10;
            max-height: 90vh; /* Schutz für kleine Screens */
            overflow-y: auto;
            user-select: none; /* Keine Textauswahl im UI */
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        .row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        label {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: #94a3b8;
            font-family: monospace;
            margin-bottom: 4px;
            width: 100%;
        }

        span.value {
            color: #22d3ee; 
            font-weight: bold;
            text-shadow: 0 0 10px rgba(34, 211, 238, 0.4);
        }

        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: #1e293b;
            border-radius: 2px;
            outline: none;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 2px; 
            background: #22d3ee; 
            cursor: pointer;
            transition: transform .1s, box-shadow 0.2s;
            box-shadow: 0 0 10px rgba(34, 211, 238, 0.5);
        }
        
        input[type=range]::-webkit-slider-thumb:hover {
            box-shadow: 0 0 15px rgba(34, 211, 238, 0.8);
        }

        input[type=checkbox] {
            accent-color: #22d3ee;
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        button {
            background: linear-gradient(135deg, #06b6d4, #22d3ee);
            color: #000510;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.8rem;
            cursor: pointer;
            transition: filter 0.2s;
            font-family: monospace;
            text-transform: uppercase;
            width: 100%;
            box-shadow: 0 0 15px rgba(6, 182, 212, 0.3);
        }

        button:hover {
            filter: brightness(1.1);
        }

        .divider {
            height: 1px;
            background-color: #1e293b;
            margin: 5px 0;
        }
        
        /* Scrollbar styling für controls container falls nötig */
        .controls-container::-webkit-scrollbar {
            width: 6px;
        }
        .controls-container::-webkit-scrollbar-track {
            background: #000510;
        }
        .controls-container::-webkit-scrollbar-thumb {
            background: #1e293b;
            border-radius: 3px;
        }
    </style>
</head>
<body>

    <canvas id="mainCanvas"></canvas>

    <div class="controls-container">
        <!-- Rotation -->
        <div class="control-group">
            <label>
                Rotation
                <span id="angleVal" class="value">160°</span>
            </label>
            <input type="range" id="angleSlider" min="0" max="360" step="0.1" value="160">
        </div>

        <!-- Sichel Breite -->
        <div class="control-group">
            <label>
                Sichel-Breite
                <span id="crescentVal" class="value">0.6</span>
            </label>
            <input type="range" id="crescentSlider" min="40" max="150" value="60">
        </div>

        <!-- Verlaufshärte -->
        <div class="control-group">
            <label>
                Verlaufshärte
                <span id="hardnessVal" class="value">50%</span>
            </label>
            <input type="range" id="hardnessSlider" min="0" max="100" value="50">
        </div>

        <!-- Raster Abstand -->
        <div class="control-group">
            <label>
                Raster-Abstand
                <span id="spacingVal" class="value">15px</span>
            </label>
            <input type="range" id="spacingSlider" min="10" max="60" value="15">
        </div>

         <!-- Max Größe -->
         <div class="control-group">
            <label>
                Max. Größe (proportional)
                <span id="maxSizeVal" class="value">90%</span>
            </label>
            <input type="range" id="maxSizeSlider" min="10" max="300" value="90">
        </div>

        <!-- Organik / Rauschen -->
        <div class="control-group">
            <label>
                Organisches Ausfransen
                <span id="noiseVal" class="value">60%</span>
            </label>
            <input type="range" id="noiseSlider" min="0" max="100" value="60">
        </div>

        <div class="divider"></div>

        <!-- Helligkeit Modus -->
        <div class="row">
            <label for="sizeModeCheck" style="margin:0; cursor:pointer;">Größe steuert Helligkeit</label>
            <input type="checkbox" id="sizeModeCheck">
        </div>

        <!-- Connections (NEU) -->
        <div class="row">
            <label for="connCheck" style="margin:0; cursor:pointer;">Connections</label>
            <input type="checkbox" id="connCheck">
        </div>

        <div class="control-group">
            <label>
                Connection Dist
                <span id="connDistVal" class="value">25px</span>
            </label>
            <input type="range" id="connDistSlider" min="10" max="100" value="25">
        </div>

        <div class="divider"></div>

        <!-- Animation Controls (Verschoben nach unten) -->
        <div class="row">
            <label for="animCheck" style="margin:0; cursor:pointer; color: #ccfbf1; font-weight:bold;">Animation (Rotation)</label>
            <input type="checkbox" id="animCheck">
        </div>

        <div class="control-group">
            <label>
                Tempo
                <span id="speedVal" class="value">1x</span>
            </label>
            <input type="range" id="speedSlider" min="1" max="50" value="10">
        </div>

        <div class="divider"></div>

        <!-- Export -->
        <div class="row">
            <button onclick="exportSVG()">SVG Export</button>
            <div style="display:flex; align-items:center; gap:5px;">
                <input type="checkbox" id="bgExportCheck" checked>
                <label for="bgExportCheck" style="margin:0; font-size:0.7rem; width:auto;">Hintergrund</label>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        
        // UI Elemente
        const els = {
            anim: document.getElementById('animCheck'),
            speed: { input: document.getElementById('speedSlider'), display: document.getElementById('speedVal') },
            angle: { input: document.getElementById('angleSlider'), display: document.getElementById('angleVal') },
            crescent: { input: document.getElementById('crescentSlider'), display: document.getElementById('crescentVal') },
            hardness: { input: document.getElementById('hardnessSlider'), display: document.getElementById('hardnessVal') },
            spacing: { input: document.getElementById('spacingSlider'), display: document.getElementById('spacingVal') },
            maxSize: { input: document.getElementById('maxSizeSlider'), display: document.getElementById('maxSizeVal') },
            noise: { input: document.getElementById('noiseSlider'), display: document.getElementById('noiseVal') },
            sizeMode: document.getElementById('sizeModeCheck'),
            conn: document.getElementById('connCheck'),
            connDist: { input: document.getElementById('connDistSlider'), display: document.getElementById('connDistVal') },
            bgExport: document.getElementById('bgExportCheck')
        };

        let width, height, minDim;
        const dpr = window.devicePixelRatio || 1;
        
        // Animation State
        let animationFrameId;

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            minDim = Math.min(width, height);
            
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;
            
            ctx.scale(dpr, dpr);
            if (!els.anim.checked) render();
        }

        function pseudoRandom(x, y) {
            return Math.abs(Math.sin(x * 12.9898 + y * 78.233) * 43758.5453) % 1;
        }

        const COLOR_CYAN_RGB = "0, 255, 255"; 

        function getPlusPathData(x, y, scale, spacing, maxSizeFactor) {
            const maxSize = spacing * maxSizeFactor; 
            const size = maxSize * scale;
            const s = size / 2;
            const t = Math.max(0.5, size * 0.15); 

            return `M ${x-t} ${y-s} L ${x+t} ${y-s} L ${x+t} ${y-t} L ${x+s} ${y-t} L ${x+s} ${y+t} L ${x+t} ${y+t} L ${x+t} ${y+s} L ${x-t} ${y+s} L ${x-t} ${y+t} L ${x-s} ${y+t} L ${x-s} ${y-t} L ${x-t} ${y-t} Z`; 
        }

        function drawSinglePathPlus(x, y, scale, spacing, sizeMode, maxSizeFactor) {
            ctx.beginPath();
            
            let drawScale = scale;
            let alpha = scale;

            if (sizeMode) {
                alpha = 1.0;
                drawScale = Math.pow(scale, 1.5); 
            }
            
            ctx.fillStyle = `rgba(${COLOR_CYAN_RGB}, ${alpha})`;

            const maxSize = spacing * maxSizeFactor; 
            const size = maxSize * drawScale;
            
            const s = size / 2;
            const t = Math.max(0.5, size * 0.15); 

            ctx.moveTo(x - t, y - s); 
            ctx.lineTo(x + t, y - s); 
            ctx.lineTo(x + t, y - t); 
            ctx.lineTo(x + s, y - t); 
            ctx.lineTo(x + s, y + t); 
            ctx.lineTo(x + t, y + t); 
            ctx.lineTo(x + t, y + s); 
            ctx.lineTo(x - t, y + s); 
            ctx.lineTo(x - t, y + t); 
            ctx.lineTo(x - s, y + t); 
            ctx.lineTo(x - s, y - t); 
            ctx.lineTo(x - t, y - t); 
            
            ctx.closePath();
            ctx.fill();
        }

        function getRenderData() {
            // angle wird als Float geparst für smootheren Input
            const angleDeg = parseFloat(els.angle.input.value);
            const crescentFactor = parseInt(els.crescent.input.value) / 100; 
            const spacing = parseInt(els.spacing.input.value);
            const noiseFactor = parseInt(els.noise.input.value) / 100;
            const hardnessFactor = parseInt(els.hardness.input.value) / 100; 
            const maxSizeFactor = parseInt(els.maxSize.input.value) / 100; 
            const sizeMode = els.sizeMode.checked;
            // Connections
            const showConn = els.conn.checked;
            const connDist = parseInt(els.connDist.input.value);

            const centerX = width / 2;
            const centerY = height / 2;
            const moonRadius = minDim * 0.35; 
            
            const shadowOffset = moonRadius * crescentFactor; 
            const blurFactor = 1.5 - (hardnessFactor * 1.4); 
            const blurSize = moonRadius * blurFactor;

            const angleRad = (angleDeg * Math.PI) / 180;
            const shadowX = centerX - Math.cos(angleRad) * shadowOffset;
            const shadowY = centerY - Math.sin(angleRad) * shadowOffset;

            const scanRadius = moonRadius + spacing + blurSize/2;
            const startCol = Math.floor((centerX - scanRadius) / spacing);
            const endCol = Math.ceil((centerX + scanRadius) / spacing);
            const startRow = Math.floor((centerY - scanRadius) / spacing);
            const endRow = Math.ceil((centerY + scanRadius) / spacing);

            let points = [];

            for (let i = startCol; i <= endCol; i++) {
                for (let j = startRow; j <= endRow; j++) {
                    const x = i * spacing;
                    const y = j * spacing;

                    const distToCenter = Math.hypot(x - centerX, y - centerY);
                    if (distToCenter > moonRadius) continue;

                    const distToShadow = Math.hypot(x - shadowX, y - shadowY);

                    let intensity = (distToShadow - (moonRadius - blurSize * 0.5)) / blurSize;
                    intensity = Math.max(0, Math.min(1, intensity));

                    if (intensity < 0.95) {
                        const rand = pseudoRandom(i, j);
                        const noiseMod = 1.0 - (hardnessFactor * 0.5); 
                        const dropoutThreshold = (1 - intensity) * noiseFactor * 2.0 * noiseMod;

                        if (rand < dropoutThreshold) continue;
                        
                        if (noiseFactor > 0) {
                             intensity *= (1 - (rand * noiseFactor * 0.3));
                        }
                    }

                    if (intensity > 0.05) {
                        points.push({x, y, intensity, spacing});
                    }
                }
            }
            return { points, sizeMode, width, height, maxSizeFactor, showConn, connDist };
        }

        function render() {
            // UI Update
            const angleVal = parseFloat(els.angle.input.value).toFixed(0);
            els.angle.display.innerText = angleVal + "°";
            els.crescent.display.innerText = (parseInt(els.crescent.input.value) / 100).toFixed(1);
            els.hardness.display.innerText = els.hardness.input.value + "%";
            els.spacing.display.innerText = els.spacing.input.value + "px";
            els.maxSize.display.innerText = els.maxSize.input.value + "%";
            els.noise.display.innerText = els.noise.input.value + "%";
            els.connDist.display.innerText = els.connDist.input.value + "px";
            const speed = parseInt(els.speed.input.value);
            els.speed.display.innerText = (speed / 10).toFixed(1) + "x";

            ctx.clearRect(0, 0, width, height);

            const data = getRenderData();
            
            // 1. Draw Connections (Lines) first (behind symbols)
            if (data.showConn) {
                const maxDist = data.connDist;
                ctx.lineWidth = 0.5;
                
                // Optimierung: Punkte sind grob nach X sortiert, da Spaltenweise generiert
                for (let i = 0; i < data.points.length; i++) {
                    const p1 = data.points[i];
                    
                    // Wir schauen uns nur nachfolgende Punkte an, um Duplikate zu vermeiden
                    for (let j = i + 1; j < data.points.length; j++) {
                        const p2 = data.points[j];
                        
                        // Abbruchbedingung für X (Da sortiert)
                        const dx = p2.x - p1.x;
                        if (dx > maxDist) break; 
                        
                        const dy = Math.abs(p2.y - p1.y);
                        if (dy > maxDist) continue;

                        const dist = Math.hypot(dx, dy);
                        if (dist <= maxDist) {
                            // Opacity sinkt mit Distanz
                            const opacity = (1 - dist / maxDist) * 0.4; // Max 0.4 alpha
                            
                            ctx.beginPath();
                            ctx.strokeStyle = `rgba(0, 255, 255, ${opacity})`;
                            ctx.moveTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                            ctx.stroke();
                        }
                    }
                }
            }

            // 2. Draw Symbols
            data.points.forEach(p => {
                drawSinglePathPlus(p.x, p.y, p.intensity, p.spacing, data.sizeMode, data.maxSizeFactor);
            });
        }

        // Animation Loop
        function animate() {
            if (!els.anim.checked) return;

            const speed = parseInt(els.speed.input.value);
            const increment = speed * 0.05; 
            
            let currentAngle = parseFloat(els.angle.input.value);
            currentAngle = (currentAngle + increment) % 360;
            
            els.angle.input.value = currentAngle;
            
            render();
            animationFrameId = requestAnimationFrame(animate);
        }

        els.anim.addEventListener('change', () => {
            if (els.anim.checked) {
                animate();
            } else {
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
            }
        });

        function exportSVG() {
            const data = getRenderData();
            const includeBg = els.bgExport.checked;
            
            let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${data.width} ${data.height}" width="${data.width}px" height="${data.height}px">`;
            
            if (includeBg) {
                // Gradient Definition hinzufügen um CSS radial-gradient zu matchen
                svg += `
                <defs>
                    <radialGradient id="bgGrad" cx="50%" cy="50%" r="71%" fx="50%" fy="50%">
                        <stop offset="0%" style="stop-color:#001e45;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#000510;stop-opacity:1" />
                    </radialGradient>
                </defs>
                <rect width="100%" height="100%" fill="url(#bgGrad)"/>
                `;
            }

            // 1. Export Connections
            if (data.showConn) {
                const maxDist = data.connDist;
                let linesSvg = "";
                
                for (let i = 0; i < data.points.length; i++) {
                    const p1 = data.points[i];
                    for (let j = i + 1; j < data.points.length; j++) {
                        const p2 = data.points[j];
                        const dx = p2.x - p1.x;
                        if (dx > maxDist) break;
                        const dy = Math.abs(p2.y - p1.y);
                        if (dy > maxDist) continue;

                        const dist = Math.hypot(dx, dy);
                        if (dist <= maxDist) {
                            const opacity = ((1 - dist / maxDist) * 0.4).toFixed(3);
                            linesSvg += `<line x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}" stroke="rgb(0, 255, 255)" stroke-opacity="${opacity}" stroke-width="0.5" />`;
                        }
                    }
                }
                svg += linesSvg;
            }

            // 2. Export Symbols
            data.points.forEach(p => {
                let drawScale = p.intensity;
                let opacity = p.intensity.toFixed(2);
                let fill = `rgb(0, 255, 255)`;

                if (data.sizeMode) {
                    opacity = "1";
                    drawScale = Math.pow(p.intensity, 1.5);
                }

                const d = getPlusPathData(p.x, p.y, drawScale, p.spacing, data.maxSizeFactor);
                const opacityAttr = opacity === "1" ? "" : `fill-opacity="${opacity}"`;
                
                svg += `<path d="${d}" fill="${fill}" ${opacityAttr} />`;
            });

            svg += `</svg>`;

            const blob = new Blob([svg], {type: "image/svg+xml;charset=utf-8"});
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = `moon_transparent_${Date.now()}.svg`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        window.addEventListener('resize', resize);
        
        function queueRender() {
            if (els.anim.checked && this !== els.anim) return; 
            render();
        }

        Object.values(els).forEach(el => {
            if (el === els.anim) return; 
            if(el.input) el.input.addEventListener('input', queueRender);
            else el.addEventListener('change', queueRender); 
        });

        setTimeout(resize, 100); 

    </script>
</body>
</html>
